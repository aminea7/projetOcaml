type id = string

type 'a out_arcs = (id * 'a) list

(* A graph is just a list of pairs: a node & its outgoing arcs. *)
type 'a graph = (id * 'a out_arcs) list

exception Graph_error of string

let empty_graph = []

let node_exists gr id = List.mem_assoc id gr

let out_arcs gr id =
  try List.assoc id gr
  with Not_found -> raise (Graph_error ("Node " ^ id ^ " does not exist in this graph."))

let find_arc gr id1 id2 =
  let out = out_arcs gr id1 in
  try Some (List.assoc id2 out)
  with Not_found -> None

let add_node gr id =
  if node_exists gr id then raise (Graph_error ("Node " ^ id ^ " already exists in the graph."))
  else (id, []) :: gr

let add_arc gr id1 id2 lbl =

  (* Existing out-arcs *)
  let outa = out_arcs gr id1 in

  (* Update out-arcs.
   * remove_assoc does not fail if id2 is not bound.  *)
  let outb = (id2, lbl) :: List.remove_assoc id2 outa in
  
  (* Replace out-arcs in the graph. *)
  let gr2 = List.remove_assoc id1 gr in
  (id1, outb) :: gr2

let v_iter gr f = List.iter (fun (id, out) -> f id out) gr
let v_iter2 gr f = List.iter (fun (id, out) -> f out) gr


let v_fold gr f acu = List.fold_left (fun acu (id, out) -> f acu id out) acu gr

let rec map_aux f = function
  |(x,y)::rest -> (x, f y)::(map_aux  f rest)
  |[]->[]

  
let rec map gr f   = List.map (fun (id,out) -> (id, map_aux f out)) gr 
				    
let r_pred_aux x gr = let rec rpa x acu = function
  |(id,out)::rest -> if id=x then ((rpa x (id::acu) rest) ; (Printf.fprintf "%s" id )) else (rpa x acu rest)
  |[]->[]
  in rpa x [] gr
		      
(*let r_pred gr x = List.iter (fun  x -> x) (List.map (fun (id,out2) -> r_pred_aux x out2) gr)  *)
  
let r_pred gr x = List.map (fun (id,out2) -> r_pred_aux x out2) gr)


let recherche gr source sink = let rec rech gr source sink file = function


in rech graf source sink []
